:figure-caption: Рисунок

== Лабораторная работа №0
=== Задание:
*а)* Создать в вашем *github* репозиторий *Labs*; *б)* Создать в репозитории *Labs* папку *Lab1*; *в)* в папке *Lab1* проект *Lab1 С ++* с основными настройками для микроконтроллера *STM32F411RC*; *г)* Сделать программу состоит из двух чисел, попробовать сложить несколько разных. В том числе скажем *1* и *-6*, *250* и *10*, Вывести результат в *Terminal I / O*. Объяснить результат; *д)* Запустить проект на выполнение по симулятору, посмотреть листинг дизамблера - попробовать определить где создались ваши переменные. *е)* Проверить все переменные в окне watch, сделать пошаговую отладку (F10, F11), посмотреть, как меняются переменные в окне *Watch*. заупустить резисторы и посмотреть значения регистров в которых созданы переменные (если конечно они там созданные); *ж)* Ответить на вопрос к первому разделу

=== Выполнение:
=== Выполнения заданий *а*, *б* и *в)*.
Нужно создать репозиторий на сайте *GitHub*, назвать его *Labs*, затем в нем нужно создать папку *Lab1* и в нем проект *Lab1 С ++* с основными настройками для микроконтроллера *STM32F411RC*.

=== Выполнения задания *г)*.
Напишем код программы, которая считает сумму двух символьных чисел *250* и *10*, *1* и *-6*. Код программы, представленный на рисунке ниже.

.Код программы
image::Cod.png[]

.Результат вычисления
image::result.png[]

Полученные результаты объясняются тем, что переменная *char* - 8-битное число, то есть ее вместимость 256 символов от 0 до 255. При сложении 1 + (-6) получаем число равное -5, но в переменной *char* такого числа нет и она уменьшается с конца, то есть мы получаем число 251. При суммировании чисел 10 и 250 полученный результат объясняется тем же самым, что *char* вмещает всего 256 символов и поэтому произошло переполнение переменной и всё началось сначала. То есть 250 + 10 = 255 + 5. Пятый элемент от 0 до 255 это 4.

=== Выполнения заданий *д* и *е)*.
Нужно нажать на клавишу F9 и мы зададим точку остановки. Точки остановки нужны для того, чтобы проверить код на правильность написания. Данный способ удобен, если имеет программу большого обьема, и чтобы не искать ошибку, правильную каждую строчки, просто прогоняем по этапу до каждой точки откладки и смиотрим где идет сбой. В режиме отладки можно по этапно проверять программу с помощью клавиш F10, F11. Клавиша F10 продолжает выполнение отладчика без захода в функцию. Нажав содержит F10, есть возможность обойти код, который нас устраивает. Так можно быстро перейти к проблемной части программы.

.Место нахождение переменных
image::C:/Users/Александр/Pictures/Imeg 3.png[]


=== Ответы на задание ж:

[qanda]
*1)* Дайте определение понятию «*Интегрированной среды разработки*».
----
Ответ: *Интегрированная среда разработки* (ИСР) - система программных средств, используемая программистами для разработки программного обеспечения (ПО).
----
*2)* Что такое *компилятор* и чем он отличается от *транслятора*?
----
Ответ: *Компилятор* - программа выполняющая трансляцию исходного кода из предметно-ориентированного языка на мишинно-ориентированный язык. Транслятор - это программа-переводчик. Она преобразует программу, написанную на одном из языков высокого уровня, в программе, состоящую из машинных команд. Компилятор отличается от транслятора языка написание, иначе написана на ассемблере.
----
*3)* Что такое *компоновщик* и какие функции он выполняет?
----
Ответ: Компоновщик (Линковщик) - программа собриющая исходный код на машино-ориентированном языке и производящая сборку в исполняемом модуле.
----
*4)* Почему важен процесс проектирования ПО какие задачи входят в этот процесс?
----
Ответ: процесс проектирования ПО важен, потому что при его создании происходит создание каждого отдела какой-либо фирмы. Процесс проектирования ПО включает следующие задачи: 1) выбор метода и стратегии решения; 2) выбор представления внутренних данных; 3) разработка основного алгоритма; 4) документирование ПО; 5) тестирование и подбор тестов; 6) выбор представления входных данных.
----
*5)* Дорисуйте процесс разработки ПО, описанный на изображении Процесс разработки точки зрения *IAR Workbench* с учетом итеративности связей в этом процессе
----
Ответ:
----
.Процесс разработки
image::Figure1.png[]

*6)* Зачем нужная отладка и в каких случаях она применяется? Для чего применяются точки остановки?
----
Ответ: Отладка необходима для поиска ошибок различных и багов, обнаруживающих в коде. Также для просмотра изменений числа и т.д. Необходимо исключить ошибку в большом коде, но не понятно где эта ошибка возникает и возникает так называемые точки остановки.
----
*7)* Какие еще важные инструментальные средства *IAR* можно добавить в таблицу [*Характеристики IAR*]
----
Ответ: контроль регистров.
----