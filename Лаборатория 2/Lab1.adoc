:figure-caption: Рисунок
:toc: Оглавление

= Лабораторная работа №1

== Задание
*  Написать программу вычисляющую следующее выражение -3/3U *3 ,удивиться увиденному и объяснить результат.
* Подключить плату к своему домашнему компу, проверить что все работает, плата прошивается и все работает как в аптеке.
* Запустить на плате Lab1 из https://github.com/lamer0k/stm32Labs/tree/master/Lab1
добавить main код для зажигания светодиодов

[source, cpp, linenums]
----
 RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ;
  GPIOA::ODR::ODR5::High::Set() ;
  Не забыть подключить
#include "gpioaregisters.hpp" //for Gpioa
----
* Пронаблюдать, что произошло на плате, все сфоткать.

* Сделать отчет с описание удивительных вещей из пункта а) и пошаговой работы с платой, с картинками, оглавлением, кодом и всяким модным и современным форматированием, чтобы отчет был читабельным и восхитительным. Описать ошибки которые вы получали при настройки, объяснить, что за ошибки, почему они возникли и как вы их исправили.

== Работа с программой

Была создана программа, которая вычисляет следующее выражение: -3/3U *3

image::../../GitHub/Labs1/code 2021-09-30 105650.png[]



Как мы видем приобретенный итог не соответствует верному математическому. Впрочем итог -4 не считается случайным.

Комментарий приобретенного итога связанно со специфичностью работы компилятора. Например как U являеться указателем беззнакового количества, а количество -3 являеться знаковым. То при разделения беззнакового количества на знаковое применяется беззнаковая операция разделения. И лишь только при умножение на 3 применяется верное знаковое умножение.

Первопричина не верного выполнения функции умножения укрыта в эталоне С++.

=== Проверка работоспособности платы

* Подключаем плату
* Настраиваем все в IAR, т.е. выбираем наше устройство

image::../../GitHub/Labs1/check_1_ 2021-09-30 121318.png[]

image::../../GitHub/Labs1/check_2_2021-09-30 122320.png[]

* Далее открываем проект lab1 и проверяем плату на прошиваемость
[source, cpp, linenums]
----
 #include "rccregisters.hpp" // for RCC
 std::uint32_t SystemCoreClock = 16'000'000U;
 extern "C" {
int __low_level_init(void)
{
//Switch on external 16 MHz oscillator
RCC::CR::HSION::On::Set();
while (RCC::CR::HSIRDY::NotReady::IsSet())
{
  }
  //Switch system clock on external oscillator
  RCC::CFGR::SW::Hsi::Set();
  while (!RCC::CFGR::SWS::Hsi::IsSet())
  {
  }
  RCC::APB2ENR::SYSCFGEN::Enable::Set();
  return 1;
}
}
int main()
{
  return 0;
}
----

* Следующим пунктом реализуем зажигание диода
[source, cpp, linenums]
----

 #include "rccregisters.hpp" // for RCC
 #include "gpioaregisters.hpp" //for Gpioa
 std::uint32_t SystemCoreClock = 16'000'000U;
 extern "C" {
int __low_level_init(void)
{
//Switch on external 16 MHz oscillator
 RCC::CR::HSION::On::Set();
while (RCC::CR::HSIRDY::NotReady::IsSet())
{
 }
//Switch system clock on external oscillator
RCC::CFGR::SW::Hsi::Set();
while (!RCC::CFGR::SWS::Hsi::IsSet())
{
 }
 RCC::APB2ENR::SYSCFGEN::Enable::Set();
 return 1;
 }
 }


 int main()
{
RCC::AHB1ENR::GPIOAEN::Enable::Set();
GPIOA::MODER::MODER5::Output::Set();
GPIOA::ODR::ODR5::High::Set();
 return 0;
}
----

Результатом представлен на фото ниже:

image::../../GitHub/Labs1/Фото.jpg[]